import math, time, os
from tkinter import *
import paho.mqtt.client as mqtt


##~~~~~~~~~~~~~~~~ Eoin Brennan Path Controller for Sisyphus System ~~~~~~~~~~~~~~~~~~~~~##

# Interfce system that allows control of the physical system and example behaviours of paths.
# Visualises paths generated by the pi and allows for controls of point density etc.

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~##

## User Variables

armLength = [57.5, 57.5]
drawArea = 115

## System Variables

lineThickness = 4

arms = []       # List for arms to be stored in
drawPath = []   # List for the drawn path to be stored in

buffSize = 5    # Size of buffer for number of arms drawn

startColour = [5,116,60]   # "#05743C" in RGB Decimal Values
endColour = [59,228,144]   # "#3BE490" in RGB Decimal Values

## tkinter setup

canvasSize = 1000
border = 25

## Classes

class armStructure:
    def __init__(self, arm1, arm2, midOval, colour):
        self.arm1 = arm1
        self.arm2 = arm2
        self.midOval = midOval
        self.colour = colour

    

class lineSegments:
    def __init__(self, xscreen, yscreen, line, oval):
        self.x = xscreen
        self.y = yscreen
        self.line = line
        self.oval = oval

    def __del__(self):
        if self.oval != 0:
            canvas.delete(self.oval)
        if self.lineBase != 0:
            canvas.delete(self.lineBase)
        if self.lineArm != 0:
            canvas.delete(self.lineArm)
        
        
## MQTT Connection

# Publishers
mqtt_broker = "localhost"
user_topic = "UserControlDisplay"


## Callback Functions

def UserDisplay_Callback(client,userdata,message):
    global startIndex, drawPath
    msg = str(message.payload.decode("utf-8"))
    print("Message recieved: ", msg)

    msgSplit = msg.split(",")

    if msgSplit[0] == "U":  # Checking if message is intended for the User Device
        # Handle response based on job type

        match msgSplit[1]:
            case "S":   # Case for a path starting
                print("Starting path read")
                startIndex = len(drawPath)
                if startIndex != 0:
                    startIndex = startIndex - 1
                #Mark the start of the path position in drawPath

            case "P":   # Case for path coords being sent
                print("Receiving path")
                AddDrawPoint(msgSplit)
                UpdateArms(msgSplit)

            case "F":   # Case for path finish being transmitted
                print("Path received, start drawing")

            case "R":   # Reset path drawing
                print("Reset the draw path")
                drawPath = []
                

## Functions

# Function to convert the cartesian coordinates to screen relative dimensions
def CartToScreen(x,y):
    global drawArea, canvasSize
    xout = ( ( (canvasSize/2 - 2*border) ) * (x/drawArea) ) + canvasSize/2
    yout = ( ( (canvasSize/2 - 2*border) ) * (y/drawArea) ) + canvasSize/2

    print("Screen Coords" ,xout,",",yout)
    return xout, yout

# Function to convert rgb values into hex format for arm colour
def RGBToHex(r,g,b):
    return "#{:02x}{:02x}{:02x}".format(int(r),int(g),int(b))

# Function to add new path data to be drawn
def AddDrawPoint(msg):
    x, y = CartToScreen(float(msg[2]) , float(msg[3]))

    if drawPath != []:
        index = len(drawPath) - 1
        
        line = canvas.create_line(x, y, drawPath[index].x, drawPath[index].y, width=lineThickness-1, fill='green')
        oval = DrawPoint(x, y,0.8)

        segment = lineSegments(x, y, line, oval)
        drawPath.append(segment)
    else:
        
        line = canvas.create_line(x, y, x,y, width=lineThickness-1, fill='green')
        oval = DrawPoint(x, y,0.8)
        segment = lineSegments(x, y, line, oval)
        drawPath.append(segment)

    

def UpdateArms(msg):
    print("Arm updating")

def DrawPoint(xscreen,yscreen, sizeMultiplier):
    r = canvasSize/500 * sizeMultiplier
    return canvas.create_oval( xscreen- r,  yscreen -r, xscreen + r, yscreen + r, outline = 'white', fill='white')



## Main Start

# Create base UI
root = Tk()
root.title("User Control Display")

canvas = Canvas(root, bg="#08141a", width = canvasSize, height = canvasSize)
canvas.pack()

canvas.create_oval(border, border, canvasSize-border, canvasSize-border, width=lineThickness, outline='white')
DrawPoint( canvasSize/2, canvasSize/2, 3)




# Connecting to MQTT
client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
client.on_message = UserDisplay_Callback # Setting callback function

client.connect(mqtt_broker) # Connect to the broker

print("Subscribing to topic: ", user_topic)
client.subscribe(user_topic)

client.loop_start()


root.mainloop()